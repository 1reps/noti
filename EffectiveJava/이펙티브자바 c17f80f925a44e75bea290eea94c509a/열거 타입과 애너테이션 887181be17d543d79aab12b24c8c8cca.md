# 열거 타입과 애너테이션

---

- int 상수 대신 열거 타입을 사용하라
    
    열거 타입은 일정 개수의 상수 값을 정의한 다음, 그 외의값은 허용하지 않는 타입이다.
    
    ```java
    public static final int APPLE_FUJI = 0;
    public static final int APPLE_PIPPIN = 1;
    public static final int APPLE_GRANNY_SMITH = 2;
    
    public static final int ORANGE_NAVEL = 0;
    public static final int ORANGE_TEMPLE = 1;
    public static final int ORANGE_BLOOD = 2;
    ```
    
    1. 타입 안전을 보장할 방법이 없다.
    2. 표현력이 좋지 않다.
    3. 오렌지를 건네야 할 메서드에 사과를 보내고 동등 연산자(==)로 비교하더라도 컴파일러는 아무런 경고 메시지를 출력하지 않는다.
    
    ---
    
    정수 대신 문자열 상수를 사용하는 변형 패턴도 있다. 더 나쁨.
    
    > 열거 타입(enum type)
    > 
    
    ```java
    public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
    public enum Orange { NAVEL, TEMPLE, BLOOD }
    ```
    
    자바의 열거 타입은 완전한 형태의 클래스라서 다른 언어의 열거 타입보다 훨씬 강력하다.
    
    열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
    
    열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.
    
    열거 타입은 인스턴스 통제된다.
    
    싱글턴은 원소가 하나뿐인 열거 타입이라 할 수 있고, 거꾸로 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.
    
    ---
    
    Apple과 Orange를 예로 들면, 과일의 색을 알려주거나 과일 이미지를 반환하는 메서드를 추가하고 싶을 수 있다.
    
    열거 타입에는 어떤 메서드도 추가할 수 있다.
    
    ```java
    public enum Planet {
        MERCURY(3.302e+23, 2.439e6),
        VENUS(4.869e+24, 6.052e6),
        EARTH(5.975e+24, 6.378e6),
        MARS(6.419e+23, 3.393e6),
        JUPITER(1.899e+27, 7.149e7),
        SATURN(5.685e+26, 6.027e7),
        URANUS(8.683e+25, 2.556e7),
        NEPTUNE(1.024e+26, 2.477e7);
    
        private final double mass;
        private final double radius;
        private final double surfaceGravity;
    
        private static final double G = 6.67300E-11;
    
        Planet(double mass, double radius) {
            this.mass = mass;
            this.radius = radius;
            surfaceGravity = G * mass / (radius * radius);
        }
    
        public double mass() {
            return mass;
        }
    
        public double radius() {
            return radius;
        }
    
        public double surfaceGravity() {
            return surfaceGravity;
        }
    
        public double surfaceWeight(double mass) {
            return mass * surfaceGravity; // F = ma
        }
    }
    ```
    
    열거 타입 상수 각각을 특정 데이터와 연결지으려면 **생성자에서 데이터를 받아 인스턴스 필드에 저장**하면 된다.
    
    ---
    
    Planet 열거 타입은 단순하지만 놀랍도록 강력하다. 어떤 객체의 지구에서의 무게를 입력받아 여덟 행성에서의 무게를 출력하는 일을 다음처럼 짧은 코드로 작성할 수 있다.
    
    ```java
    public static void main(String[] args) {
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight / Planet.EARTH.surfaceGravity();
        for (Planet p : Planet.values())
            System.out.printf("%s에서의 무게는 %f이다.%n", p, p.surfaceWeight(mass));
    }
    ```
    
    ---
    
    열거 타입을 선언한 클래스 혹은 그 패키지에서만 유용한 기능은 private이나 package-private 메서드로 구현한다.
    
    자신을 선언한 클래스 혹은 패키지에서만 사용할 수 있는 기능을 담게 된다.
    
    기능을 클라이언트에 노출해야 할 합당한 이유가 없다면 private으로, 혹은 package-private으로 선언하라.
    
    ```java
    public enum Operation {
        PLUS, MINUS, TIMES, DIVIDE;
    
        public double apply(double x, double y) {
            switch(this) {
                case PLUS:   return x + y;
                case MINUS:  return x - y;
                case TIMES:  return x * y;
                case DIVIDE: return x / y;
            }
            throw new AssertionError("알 수 없는 연산: " + this);
        }
    }
    ```
    
    ```java
    public enum BetterThanOperation {
        PLUS {
            public double apply(double x, double y) {
                return x + y;
            }
        },
        MINUS {
            public double apply(double x, double y) {
                return x - y;
            }
        },
        TIMES {
            public double apply(double x, double y) {
                return x * y;
            }
        },
        DIVIDE {
            public double apply(double x, double y) {
                return x / y;
            }
        };
    
        public abstract double apply(double x, double y);
    }
    ```
    
    ```java
    public enum BetterThanOperation {
        PLUS("+") {
            public double apply(double x, double y) {
                return x + y;
            }
        },
        MINUS("-") {
            public double apply(double x, double y) {
                return x - y;
            }
        },
        TIMES("*") {
            public double apply(double x, double y) {
                return x * y;
            }
        },
        DIVIDE("/") {
            public double apply(double x, double y) {
                return x / y;
            }
        };
    
        private final String symbol;
    
        BetterThanOperation(String symbol) {
            this.symbol = symbol;
        }
    
        @Override public String toString() {
            return symbol;
        }
    
        public abstract double apply(double x, double y);
    }
    ```
    
    ```java
    private static final Map<String, BetterThanOperation> stringToEnum =
            Stream.of(values()).collect(
                    toMap(Object::toString, e -> e));
    
    // 지정한 문자열에 해당하는 Operation을 (존재한다면) 반환한다.
    public static Optional<BetterThanOperation> formString(String symbol) {
        return Optional.ofNullable(stringToEnum.get(symbol));
    }
    ```
    
    Operation 상수가 stringToEnum 맵에 추가되는 시점은 열거 타입 상수 생성 후 정적 필드가 초기화될 때다.
    
    ㄴ JVM은 실행과정에서 필요한 클래스의 정보를 메모리에 로딩(Loading)하는데 이 시점에 static 변수가 초기화된다.
    
    자바 8 이전에는 빈 해시맵을 만든 다음 values가 반환한 배열을 순회하여 쌍을 맵에 추가했을 것이다.
    
    하지만 열거 타입 상수는 생성자에서 자신의 인스턴스를 맵에 추가할 수 없다.
    
    이렇게 하려면 컴파일 오류가 나는데, 만약 이 방식이 허용되었다면 런타임에 NullPointerException이 발생했을 것이다.
    
    열거 타입의 정적 필드 중 열거 타입의 생성자에서 접근할 수 있는 것은 상수 변수뿐이다.
    
    열거 타입 생성자가 실행되는 시점에는 정적 필드들이 아직 초기화되기 전이라.
    
    자기 자신을 추가하지 못하게 하는 제약이 꼭 필요하다.
    
    이 제약의 특수한 예로, 열거 타입 생성자에서 같은 열거 타입의 다른 상수에도 접근할 수 없다.
    
    fromString이 Optional<Operation>을 반환하는 점도 주의하자.
    
    이는 주어진 문자열이 가리키는 연산이 존재하지 않을 수 있음을 클라이언트에 알리고, 그 상황을 클라이언트에서 대처하도록 한 것이다.
    
    ```java
    public enum PayrollDay {
        MONDAY(WEEKEND), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY),
        THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),
    
        SATURDAY(WEEKEND), SUNDAY(WEEKEND);
    
        private final PayType payType;
    
        PayrollDay(PayType payType) {
            this.payType = payType;
        }
    
        int pay(int minutesWorked, int payRate) {
            return payType.pay(minutesWorked, payRate);
        }
    
        enum PayType {
            WEEKDAY {
                int overtimePay(int minsWorked, int payRate) {
                    return minsWorked <= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2;
                }
            },
            WEEKEND {
                int overtimePay(int minsWorked, int payRate) {
                    return minsWorked * payRate / 2;
                }
            };
    
            abstract int overtimePay(int muns, int payRate);
    
            private static final int MINS_PER_SHIFT = 8 * 60;
    
            int pay(int minsWorked, int payRate) {
                int basePay = minsWorked * payRate;
                return basePay + overtimePay(minsWorked, payRate);
            }
        }
    }
    ```
    
    34.9 까지만 작성