# 모든 객체의 공통 메서드

- equals는 일반 규약을 지켜 재정의하라
    
    equals 메서드는 다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
    
    1. 각 인스턴스가 본질적으로 고유하다. Thread가 좋은 예로, Object의 equals 메서드는 이러한 클래스에 딱 맞게 구현되었다.
    2. 인스턴스의 ‘논리적 동치성(logical equality)’을 검사할 일이 없다.
    3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
    4. 클래스가 private이거나 package-pricate이고 equals 메서드를 호출할 일이 없다.
    
    ```java
    @Override
    public boolean equals(Object obj) {
        throw new AssertionError(); // 호출 금지!
    }
    ```
    
    > equals를 재정의해야 할 때는 언제일까?
    > 
    1. 객체 식별성(object identity; 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.
    주로 값 클래스들이 여기 해당한다. 값 클래스란 Integer와 String처럼 값을 표현하는 클래스를 말한다.
    
    > equals 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.
    > 
    1. **반사성(reflexivity)**: null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다.
    2. **대칭성(symmetry)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
    3. **추이성(transitivity)**: null이 아닌 모든 참조 값 x,y,z에 대해, x.equals(y)가 true면 y.euqlas(x)도 true다.
    4. **일관성(consistency)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
    5. **null-아님**: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.
    
    .
    
    .
    
    .
    
    (내용 생략)
    

---

- equals를 재정의하려거든 hashCode도 재정의하라

---

- toString을 항상 재정의하라
    
    toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
    
    toString 메서드는 객체를 println, printf, 문자열 연결 연산자(+), assert 구문을 넘길 때, 혹은 디버거가 객체를 출력할 떄 자동으로 불린다. 
    
    toString을 제대로 재정의하지 않는다면 쓸모없는 메시지만 로그에 남을 것이다.
    
    map 객체를 출력했을 때 {Jenny=PhoneNumber@adbbd}보다는 {Jenny=707-867-5309}라는 메세지가 나오는 게 훨씬 반값지 않은가?
    
    실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.
    
    <aside>
    💡 모든 구체 클래스에서 Object의 toString을 재정의하자. 
    상위 클래스에서 이미 알맞게 재정의한 경우는 예외다.
    toString을 재정의한 클래스는 사용하기도 즐겁고 그 클래스를 사용한 시스템을 디버깅하기 쉽게 해준다.
    toString은 해당 객체에 관한 명확하고 유요한 정보를 읽기 좋은 형태로 반환해야 한다.
    
    </aside>
    

---

- clone 재정의는 주의해서 진행하라

---

- Comparable을 구현할지 고려하라
    
    Comparable 인터페이스의 유일무이한 메서드인 compareTo를 알아보자.
    
    compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다.
    
    Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서(natural order)가 있음을 뜻한다.
    
    그래서 Comparable을 구현한 객체들의 배열은 다음처럼 손쉽게 정렬할 수 있다.
    
    **Arrays.sort(a);**
    
    다음 프로그램은 명령줄 인수들을 (중복은 제거하고) 알파벳순으로 출력한다.
    
    ```java
    Set<String> s = new TreeSet<>();
    Collections.addAll(s, args);
    System.out.println(s);
    ```
    
    자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입이 Comparable을 구현했다.
    
    순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.
    
    ```java
    public interface Comparable<T> {
        int compareTo(T t);
    }
    ```
    
    > compareTo 메서드의 일반 규약
    > 
    1. 이 객체와 주어진 객체의 순서를 비교한다.
    이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환하다.
    이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCasstException을 던진다.
    2. Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다
    (따라서 x.compareTo)는 y.compareTo(x)가 예외를 던질 때에 한해 예외를 던져야 한다.)
    3. Comparable을 구현한 클래스는 추이성을 보장해야 한다. 
    즉, (x.compareTo(y) > 0 && y.compareTo(z) > 0)이면 x.compareTo(z) > 0이다.
    4. Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))다.
    5. 이번 권고가 필수는 아니지만 꼭 지키는 게 좋다. (x.compareTo(y) == 0) == (x.equals(y))여야 한다. Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 다음과 같이 명시하면 적당할 것이다.
    **”주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.”**
    
    ---
    
    compareTo는 타입이 다른 객체를 신경 쓰지 않아도 된다.
    
    타입이 다른 객체가 주어지면 간단히 ClassCastException을 던져도 되며, 대부분 그렇게 한다.
    
    compareTo 규약을 지키지 못하면 비교를 활용하는 클래스와 어울리지 못한다.
    
    비교를 활용하는 클래스의 예로는 정렬된 컬렉션인 TreeSet과 TreeMap, Collections와 Arrays가 있다.
    
    > compareTo 규약 정리
    > 
    1. 두 객체 참조의 순서를 바꿔 비교해도 에상한 결과가 나와야 한다.
    2. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다.
    
    > 주의사항
    > 
    1. 기존 클래스를 확장한 구체 클래스에서 새로운 값 컴포넌트를 추가했다면 compareTo 규약을 지킬 방법이 없다.
    
    > 우회법
    > 
    1. Comparable을 구현한 클래스를 확장해 값 컴포넌트를 추가하고 싶다면, 확장하는 대신 독립된 클래스를 만들고, 이 클래스에 원래 클래스의 인스턴스를 가리키는 필드를 두자.
    그런 다음 내부 인스턴스를 반환하는 ‘뷰’ 메서드를 제공하면 된다. 이렇게 하면 바깥 클래스에 우리가 원하는 compareTo 메서드를 구현해넣을 수 있다.
    
    > 마지막 규약
    > 
    1. compareTo 메서드로 수행한 동치성 테스트의 결과가 euqals와 같아야 한다.
    
    > compareTo와 equals가 일관되지 않는 BigDecimal 클래스를 예로 생각해보자
    > 
    
    빈 HashSet 인스턴스를 생성한 다음 new BigDecimal(”1.0”)과 new BigDecimal(”1.00”)을 차례로 추가한다.
    
    이 두 BigDecimal은 equals 메서드로 비교하면 서로 다르기 때문에 HashSet은 원소를 2개 갖게 된다.
    
    하지만 HashSet 대신 TreeSet을 사용하면 원소를 하나만 갖게 된다.
    
    compareTo 메서드로 비교하면 두 BigDecimal 인스턴스가 똑같기 때문이다.
    
    Comparable은 타입을 인수로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인수 타입은 컴파일타임에 정해진다.
    
    입력 인수의 타입을 확인하거나 형변화할 필요가 없다.
    
    또한 null을 인수로 넣어 호출하면 NullPointerException을 던져야 한다.
    
    compareTo 메서드는 각 필드가 동치인지를 비교하는 게 아니라 그 순서를 비교한다.
    
    객체 참조 필드를 비교하려면 compareTo 메서드를 귀적으로 호출한다.
    
    Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 비교자(Comparator)를 대신 사용한다.
    
    비교자는 직접 만들거나 자바가 제공하는 것 중에 골라 쓰면 된다.
    
    ```java
    public final class CaseInsensitiveString implements Comparable<CaseInsensitiveString> {
    
        @Override
        public int compareTo(CaseInsensitiveString cis) {
            return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);
        }
    }
    ```
    
    CaseInsensitiveString이 Comparable<CaseInsensitiveString>을 구현한 것에 주목하자.
    
    CaseInsensitiveString의 참조는 CaseInsensitiveString 참조와만 비교할 수 있다는 뜻으로, Comparable을 구현할 때 일반적으로 따르는 패턴이다.
    
    > 정수 기본 타입과 실수 기분 타입 필드 비교
    > 
    
    정수 기본타입 필드 비교 시<와 >를
    
    실수 기본 타입 필드를 비교할 때는 정적 메서드인 [Double.compare](http://Double.compare)와 Float.compare를 사용하라고 권했다.
    
    그런데 자바 7부터는 상황이 변했다.
    
    박싱된 기본 타입 클래스들에 새로 추가된 정적 메서드인 compare를 이용하면 되는 것이다.
    
    **compareTo 메서드에서 관계 연산자 <와 >를 사용하는 이전 방식은 거추장스럽고 오류를 유발하니, 이제는 추천하지 않는다.**
    
    클래스에 핵심 필드가 여러 개라면 어느 것을 먼저 비교하느냐가 중요해진다.
    
    가장 핵심적인 필드부터 비교해나가자. 
    
    비교 결과가 0이 아니라면, 즉 순서가 결정되면 거기서 끝이다.
    
    ```java
    public int compareTo(PhoneNumber pn) {
        int result = Short.compare(areaCode, pn.areaCode);    // 가장 중요한
        if (result == 0) {
            result = Short.compare(prefix, pn.prefix);        // 두 번째로 중요한
            if (result == 0) {
                result = Short.compare(lineNum, pn.lineNum);  // 세 번째로 중요한
            }
        }
        return result;
    }
    ```
    
    > 자바 8에서는 Comparator 인터페이스가 일련의 비교자 생성 메서드와 팀을 꾸려 메서드 연쇄 방식으로 비교자를 생성
    > 
    
    간결함에 매혹되지만, 약간의 성능 저하가 뒤따른다.
    
    PhoneNumber 인스턴스의 정렬된 배열에 적용해보니 10% 정도 느려졌다.
    
    자바의 정적 임포트 기능을 이용하면 정적 비교자 생성 메서드들을 그 이름만으로 사용할 수 있어 코드가 훨씬 깔끔해진다.
    
    ```java
    private static final Comparator<PhoneNumber> COMPARATOR = 
    				comparingInt((PhoneNumber pn) -> pn.areaCode)
    						.thenComparingInt(pn -> pn.prefix)
    						.thenComparingInt(pn -> pn.lineNum);
    
    public int compareTo(PhoneNumber pn) {
        return COMPARATOR.compare(this, pn);
    }
    ```
    
    <aside>
    💡 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러 지도록 해야 한다.
    compareTo 메서드에서 필드의 을 비교할 때 <와 > 연산자는 쓰지 말아야 한다.
    그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.
    
    </aside>
    

---