# 제네릭

---

- 로 타입은 사용하지 말라
    
    클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이면, 이를 **제네릭 클래스** 혹은 **제네릭 인터페이스**라 한다.
    
    예컨데 List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다.
    
    그래서 이 인터페이스의 완전한 이름은 List<E>지만, 짧게 그냥 List라고도 자주 쓴다.
    
    제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입(generic type)이라 한다.
    
    ---
    
    각각의 제네릭 타입은 일련의 **매개변수화 타입**(parameterized type)을 정의한다.
    
    List<String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입니다.
    
    여기서 String이 정규(formal) 타입 매개변수 E에 해당하는 실제(actual) 타입 매개변수다.
    
    ---
    
    제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의된다.
    
    로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
    
    예컨데 List<E>의 로 타입은 List다.
    
    로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래 하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.
    
    ---
    
    ```java
    // Stamp 인스턴스만 취급한다.
    private final Collection stamps = ...;
    ```
    
    ```java
    // 실수로 동전을 넣는다.
    stamps.add(new Coin(...)); // "unchecked call" 경고를 내뱉는다.
    ```
    
    컬렉션에서 이 동전을 다시 꺼내기 전에는 오류를 알아채지 못한다.
    
    ```java
    for (Iterator i = stamps.iterator(); i.hasNext();) {
        Stamp stamp = (Stamp) i.next(); // ClassCastException을 던진다.
        stamp.cancel();
    }
    ```
    
    ---
    
    제네릭을 활용하면 이 정보가 주석이 아닌 타입 선언 자체에 녹아든다.
    
    ```java
    private static final Collection<Stemp> stemps = ...;
    ```
    
    **로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.**
    
    ---
    
    List 같은 로 타입은 사용해서는 안 되나, List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
    
    로 타입인 List와 매개변수화 타입인 List<Object>의 차이는 무엇일까?
    
    List는 제네릭 타입에서 완전히 발을 뺀 것이고, List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다.
    
    매개변수로 List를 받는 메서드에 List<String>을 넘길 수 있지만, List<Object>를 받는 메서드에는 넘길 수 없다.
    
    이는 제네릭의 하위 타입 규칙 떄문이다.
    
    즉. List<String>은 로 타입인 List의 하위 타입이지만, List<Object>의 하위 타입은 아니다.
    
    그 결과, **List<Object> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안전성을 잃게 된다.**
    
    제네릭 타입인 Set<E>의 비한정적 와일드카드 타입은 Set<?>다.
    이것이 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 Set 타입니다.
    
    ```java
    static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
    ```
    
    **다음은 제네릭 타입에 instanceof를 사용하는 올바른 예다.**
    
    ```java
    if (o instanceof Set) {     // 로 타입
    		Set<?> s = (Set<?>) o;  // 와일드카드 타입
    }
    ```
    
    > o의 타입이 Set임을 확인한 다음 와일드카드 타입인 Set<?>로 형변환해야 한다(로 타입인 Set이 아니다.)
    이는 검사 형변환(checked cast)이므로 컴파일러 경고가 뜨지 않는다.
    > 
    
    <aside>
    💡 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다.
    로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
    빠르게 훑어보자면, Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, 
    Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다. 
    그리고 이들의 로 탕비인 Set은 제네릭 타입 시스템에 속하지 않는다.
    Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.
    
    </aside>
    
    | 한글 용어 | 예 |
    | --- | --- |
    | 매개변수화 타입 | List<String> |
    | 실제 타입 매개변수 | String |
    | 제네릭 타입 | List<E> |
    | 정규 타입 매개변수 | E |
    | 비한정적 와일드카드 | List<?> |
    | 로 타입 | List |
    | 한정적 타입 매개변수 | <E extends Number> |
    | 재귀적 타입 한정 | <T extends Comparable<T>> |
    | 한정적 와일드카드 타입 | List<? extends Number> |
    | 제네릭 메서드 | static <E> List<E> asList<E[] a> |
    | 타입 토큰 | String.class |
    
    ---
    

---

- 비검사 경고를 제거하라(미작성)

---

- 배열보다는 리스트를 사용하라